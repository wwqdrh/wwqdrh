go内存优化实践: 包括了内存的基础知识、如何对go程序的内存使用情况进行分析，如何进行优化

# 简介

内存和gc

从全貌搞清楚

在考虑细节，例如如何找到mcache对象

- 堆栈和逃逸分析
- 连续栈
- 内存结构
- 优化实践

# 内存

堆和栈

go中可以分配内存的空间只有两个，一个是全局堆空间，还有每个goroutine的自身的栈空间（由编译器自动分配和释放，随着函数的创建而创建，函数的返回而返回）

堆空间可以作为对象跨iframe的引用

只要这个对象会被外部函数访问，那么编译器就会将其自动分配到堆上。

可以通过`go build -gcflags -m ./gc/main.go`来明确当前哪些变量是逃逸的

```bash
# command-line-arguments
gc/main.go:12:18: inlining call to rand.Intn
gc/main.go:5:6: can inline main
gc/main.go:12:2: moved to heap: tmp
```

最后一行说明了tmp变量逃逸到了堆上

当一个函数被调用时，会在两个相关的帧边界间进行上下文切换。从调用函数切换到被调用函数，如果函数调用时需要传递参数，那么这些参数值也要传递到被调用函数的帧边界中。

函数返回时这些参数在的栈帧不能进行访问。

# gc

堆中对象的扫描，回收不再使用的对象

对象是否包含指针

# 栈实现

分段栈会有“hot split问题”，如果栈快满了，那么下次函数调用的时候，会触发栈扩容。当函数返回的时候，新分配的栈区会被清理

在1.3后实现连续栈，采用复制栈的实现方式，在热分裂场景中不会频繁释放内存，大小也改回了2k

当使用栈不超过1/4，触发缩容，与扩容流程一样

连续栈，触发扩栈，

`如何判断栈空间不够`

